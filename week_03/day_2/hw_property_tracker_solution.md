CRUD Quiz: Property Tracker

## MVP

In our Property Tracker application:

**Q1. where are we instantiating instances of the Property class?**

console.rb

**Q2. where are we defining the SQL that enables us to save the ruby Property object into the database?**

In the Property’s ‘save’ method.

**Q3. In the console.rb, which lines modify the database?**

- property1.save()
- property2.save()
- property3.save()
- property1.delete()

**Why do we not define the id of a Property object at the point we instantiate it (‘new it up’)?**

Because we want the database to be responsible for creating the id. This ensures the id will be unique.

**Q5. Where and how do we assign the property id (that is generated by the database) to the ruby object?**

In the `save` method, when we have saved a database to the database, we ask the database to give us back the ID it has generated. We then assign is to the Property object’s instance variable.

**Q6. Why do we put a guard (an ‘if’ clause) on the @id attribute in the constructor?**

Because, when we first instantiate the Property object ourselves, we don’t expect the object to have an id. The id is set only when the object is saved to the database, and we expect id’s in Property objects returned from the database. The guard allows the constructor to be used for both of these circumstances.

**Q7. Why are some of the CRUD actions represented by instance methods, and others, class methods?**

Some of the methods are specific to a particular instance of Property, and others are not. So while we want to call `save` on an instance of Property (‘property1.save), we don’t want to call `all` on a particular instance of Property. It wouldn’t make sense to make it the responsibility of one Property object to get all the Property objects. In this case we make `all` a class method, where we call the method on the whole class with `Property.all`

**Q8. What type of data structure is returned by db.exec() and db.exec_prepared(), and how do we index into it to pull out a desired attribute?**

It’s something like an ‘array of hashes’, where each hash represents a Property object stored in the database.  We drill down first into the array with an index (accessing a hash), and then into the hash with a key corresponding to the string of the name of the desired attribute in the Property object.

**Q9. Why do we use prepared statements when performing database operations?**

To avoid the possibility of ‘SQL injection’ attacks, where a malicious actor could append SQL command syntax to the end of data passed in to our app. The prepared statement recognises and ‘trims out’ SQL syntax from what should be pure data fields.


## Extensions

Look at the `find_by_id` and `find_by_address` in the
Property class.

**Q10. What do they take in as their arguments?**

`find_by_id` takes an id as an integer
`find_by_address` takes an address as a string

**Q11. What is their return value?**

Both return an instance of a property.
